diff --git a/include/internal/catch_approx.hpp b/include/internal/catch_approx.hpp
index f5dba61..08a15b7 100644
--- a/include/internal/catch_approx.hpp
+++ b/include/internal/catch_approx.hpp
@@ -20,12 +20,14 @@ namespace Detail {
     public:
         explicit Approx ( double value )
         :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),
+            m_margin( 0.0 ),
             m_scale( 1.0 ),
             m_value( value )
         {}
 
         Approx( Approx const& other )
         :   m_epsilon( other.m_epsilon ),
+            m_margin( other.m_margin ),
             m_scale( other.m_scale ),
             m_value( other.m_value )
         {}
@@ -37,13 +39,19 @@ namespace Detail {
         Approx operator()( double value ) {
             Approx approx( value );
             approx.epsilon( m_epsilon );
+            approx.margin( m_margin );
             approx.scale( m_scale );
             return approx;
         }
 
         friend bool operator == ( double lhs, Approx const& rhs ) {
             // Thanks to Richard Harris for his help refining this formula
-            return fabs( lhs - rhs.m_value ) < rhs.m_epsilon * (rhs.m_scale + (std::max)( fabs(lhs), fabs(rhs.m_value) ) );
+            bool relativeOK = fabs( lhs - rhs.m_value ) < rhs.m_epsilon * (rhs.m_scale + (std::max)( fabs(lhs), fabs(rhs.m_value) ) );
+            if ( relativeOK ) {
+                return true;
+            }
+            bool absoluteOK = fabs( lhs - rhs.m_value ) < rhs.m_margin;
+            return absoluteOK;
         }
 
         friend bool operator == ( Approx const& lhs, double rhs ) {
@@ -63,6 +71,11 @@ namespace Detail {
             return *this;
         }
 
+        Approx& margin( double newMargin ) {
+            m_margin = newMargin;
+            return *this;
+        }
+
         Approx& scale( double newScale ) {
             m_scale = newScale;
             return *this;
@@ -76,6 +89,7 @@ namespace Detail {
 
     private:
         double m_epsilon;
+        double m_margin;
         double m_scale;
         double m_value;
     };
diff --git a/include/internal/catch_test_case_registry_impl.hpp b/include/internal/catch_test_case_registry_impl.hpp
index 728adcb..fa84ba2 100644
--- a/include/internal/catch_test_case_registry_impl.hpp
+++ b/include/internal/catch_test_case_registry_impl.hpp
@@ -107,7 +107,7 @@ namespace Catch {
             if( m_sortedFunctions.empty() )
                 enforceNoDuplicateTestCases( m_functions );
 
-            if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {
+            if(  m_sortedFunctions. empty() || m_currentSortOrder != config.runOrder() ) {
                 m_sortedFunctions = sortTests( config, m_functions );
                 m_currentSortOrder = config.runOrder();
             }
diff --git a/single_include/catch.hpp b/single_include/catch.hpp
index 1d0d808..922e857 100644
--- a/single_include/catch.hpp
+++ b/single_include/catch.hpp
@@ -2581,12 +2581,14 @@ namespace Detail {
     public:
         explicit Approx ( double value )
         :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),
+            m_margin( 0.0 ),
             m_scale( 1.0 ),
             m_value( value )
         {}
 
         Approx( Approx const& other )
         :   m_epsilon( other.m_epsilon ),
+            m_margin( other.m_margin ),
             m_scale( other.m_scale ),
             m_value( other.m_value )
         {}
@@ -2598,13 +2600,19 @@ namespace Detail {
         Approx operator()( double value ) {
             Approx approx( value );
             approx.epsilon( m_epsilon );
+            approx.margin( m_margin );
             approx.scale( m_scale );
             return approx;
         }
 
         friend bool operator == ( double lhs, Approx const& rhs ) {
             // Thanks to Richard Harris for his help refining this formula
-            return fabs( lhs - rhs.m_value ) < rhs.m_epsilon * (rhs.m_scale + (std::max)( fabs(lhs), fabs(rhs.m_value) ) );
+            bool relativeOK = fabs( lhs - rhs.m_value ) < rhs.m_epsilon * (rhs.m_scale + (std::max)( fabs(lhs), fabs(rhs.m_value) ) );
+            if ( relativeOK ) {
+                return true;
+            }
+            bool absoluteOK = fabs( lhs - rhs.m_value ) < rhs.m_margin;
+            return absoluteOK;
         }
 
         friend bool operator == ( Approx const& lhs, double rhs ) {
@@ -2624,6 +2632,11 @@ namespace Detail {
             return *this;
         }
 
+        Approx& margin( double newMargin ) {
+            m_margin = newMargin;
+            return *this;
+        }
+
         Approx& scale( double newScale ) {
             m_scale = newScale;
             return *this;
@@ -2637,6 +2650,7 @@ namespace Detail {
 
     private:
         double m_epsilon;
+        double m_margin;
         double m_scale;
         double m_value;
     };
@@ -6268,7 +6282,7 @@ namespace Catch {
             if( m_sortedFunctions.empty() )
                 enforceNoDuplicateTestCases( m_functions );
 
-            if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {
+            if( m_sortedFunctions.empty() || m_currentSortOrder != config.runOrder() ) {
                 m_sortedFunctions = sortTests( config, m_functions );
                 m_currentSortOrder = config.runOrder();
             }
